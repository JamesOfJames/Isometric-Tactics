<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
DM = 0 ;
CM = 0 ;

ShowOutlines = false ;
ShowCosts   = true ;

randomize() ;

MyGraph = path_finder_grid_declare(30,20) ;
demo_path_finder_grid_define(MyGraph) ;

var W = ds_grid_width(MyGraph) ;
var H = ds_grid_height(MyGraph) ;

//Find Start
do
    {
    X = irandom_range(1,W-2) ;
    Y = irandom_range(1,H-2) ;
    S = path_finder_grid_cell_get_id(MyGraph,X,Y)
    }
until ( path_finder_grid_cell_passable(MyGraph,X,Y))

//Find goal
do
    {
    X = irandom_range(1,W-2) ;
    Y = irandom_range(1,H-2) ;
    G = path_finder_grid_cell_get_id(MyGraph,X,Y)
    }
until ( path_finder_grid_cell_passable(MyGraph,X,Y))




TerrainMap = ds_map_create() ;
//I Reccomend Creating Constants for your Terrain types but since constants don't ship with Marketplace Assets they are real values
ds_map_add(TerrainMap,1,9999) ; //Wall Case , doesn't need to be there but incase passable returns true when it shouldn't a high cost prevents us from going in it.
ds_map_add(TerrainMap,0,1) ; //Standard Floor
ds_map_add(TerrainMap,-1,9) ; //It costs more to tranverse water
ds_map_add(TerrainMap,-2,12) ; //Extra Cost for this terrain


MyWeights = path_finder_grid_declare_weights(MyGraph,TerrainMap,1) ;
MoveWeight = path_finder_directional_weight_grid_declare(3,2,3,1,1,3,2,3) ;

//Fills the Paths Array with paths from generated from the algorithms
Paths[0] = path_finder_breadth_first_search(MyGraph,S,G) ;
Paths[1] = path_finder_dijkstra_search(MyGraph,MyWeights,S,G,0) ;
Paths[2] = path_finder_greedy_first_search(MyGraph,S,G) ;
Paths[3] = path_finder_a_star_search(MyGraph,MyWeights,S,G,0) ;
Paths[4] = path_finder_breadth_first_search_8d(MyGraph,S,G) ;
Paths[5] = path_finder_dijkstra_search_8d(MyGraph,MyWeights,S,G,0) ;
Paths[6] = path_finder_greedy_first_search_8d(MyGraph,S,G) ;
Paths[7] = path_finder_a_star_search_8d(MyGraph,MyWeights,S,G,0) ;
Paths[8] = path_finder_dijkstra_search_8d_weighted(MyGraph,MyWeights,S,G,0,MoveWeight) ;
Paths[9] = path_finder_a_star_search_8d_weighted(MyGraph,MyWeights,S,G,0,MoveWeight) ;



//Fills the Costs Array with costs for Dijkstra and A* Methods
Costs[0] = path_finder_dijkstra_search(MyGraph,MyWeights,S,G,1) ;
Costs[1] = path_finder_a_star_search(MyGraph,MyWeights,S,G,1) ;
Costs[2] = path_finder_dijkstra_search_8d(MyGraph,MyWeights,S,G,1) ;
Costs[3] = path_finder_a_star_search_8d(MyGraph,MyWeights,S,G,1) ;
Costs[4] = path_finder_dijkstra_search_8d_weighted(MyGraph,MyWeights,S,G,1,MoveWeight) ;
Costs[5] = path_finder_a_star_search_8d_weighted(MyGraph,MyWeights,S,G,1,MoveWeight) ;



//If you can find the goal in each of the paths we'll grab the one from the start to the goal and store it in TruePath (as a ds_list) and PathPath as an actual Path
for(var i = 0 ; i &lt; 10 ; i++)
    {
    show_debug_message("i : " + string(i)) ;
    var Can = path_finder_can_reach_goal(Paths[i],S,G) ;
    show_debug_message("CAN : " + string(Can)) ;
    if (Can)
        {
        TruePath[i] = path_finder_path_to_goal(Paths[i],S,G) ;
        if (ds_exists(TruePath[i],ds_type_list))
            {
            TruePathLength[i] = ds_list_size(TruePath[i]) ;
            }
        
        PathPath[i] = path_finder_list_to_path(MyGraph,TruePath[i],32,32,32)
        ds_list_print_to_console("Path Test : " + string(i),"End Path Test",TruePath[i]) ;
        
        }
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Fetchs the Relative Coordinates for the grid
var X = floor(mouse_x/32) - 1 ;
var Y = floor(mouse_y/32) - 1 ;

//Finds that Cell ID
var Cell = path_finder_grid_cell_get_id(MyGraph,X,Y)

//Each case 
if (CM == 0) { S = Cell } ;
if (CM ==1) {  G = Cell } ;
if (CM ==2) { path_finder_grid_cell_set_wall(MyGraph,X,Y) } ;
if (CM ==3) { ds_grid_set(MyGraph,X,Y,0) } ;
if (CM ==4) { ds_grid_set(MyGraph,X,Y,-1) } ;


//Regenerate the Weights
MyWeights = path_finder_grid_declare_weights(MyGraph,TerrainMap,1) ;


//Loop through each of the Path and destroy everything to do with them
var PS = array_length_1d(Paths) ;
for(var i = 0 ; i &lt; PS ; i++)
    {
    ds_map_destroy(Paths[i]) ;
    ds_list_destroy(TruePath[i]); 
    }
    

//Destroy the Costs    
var CS = array_length_1d(Costs) 
for ( var i = 0 ; i &lt;  CS ; i++)
    {
    ds_map_destroy(Costs[i]) ;
    }



//Regenerate what we need.
Paths[0] = path_finder_breadth_first_search(MyGraph,S,G) ;
Paths[1] = path_finder_dijkstra_search(MyGraph,MyWeights,S,G,0) ;
Paths[2] = path_finder_greedy_first_search(MyGraph,S,G) ;
Paths[3] = path_finder_a_star_search(MyGraph,MyWeights,S,G,0) ;
Paths[4] = path_finder_breadth_first_search_8d(MyGraph,S,G) ;
Paths[5] = path_finder_dijkstra_search_8d(MyGraph,MyWeights,S,G,0) ;
Paths[6] = path_finder_greedy_first_search_8d(MyGraph,S,G) ;
Paths[7] = path_finder_a_star_search_8d(MyGraph,MyWeights,S,G,0) ;
Paths[8] = path_finder_dijkstra_search_8d_weighted(MyGraph,MyWeights,S,G,0,MoveWeight) ;
Paths[9] = path_finder_a_star_search_8d_weighted(MyGraph,MyWeights,S,G,0,MoveWeight) ;



//Fills the Costs Array with costs for Dijkstra and A* Methods
Costs[0] = path_finder_dijkstra_search(MyGraph,MyWeights,S,G,1) ;
Costs[1] = path_finder_a_star_search(MyGraph,MyWeights,S,G,1) ;
Costs[2] = path_finder_dijkstra_search_8d(MyGraph,MyWeights,S,G,1) ;
Costs[3] = path_finder_a_star_search_8d(MyGraph,MyWeights,S,G,1) ;
Costs[4] = path_finder_dijkstra_search_8d_weighted(MyGraph,MyWeights,S,G,1,MoveWeight) ;
Costs[5] = path_finder_a_star_search_8d_weighted(MyGraph,MyWeights,S,G,1,MoveWeight) ;


for(var i = 0 ; i &lt; 10 ; i++)
    {
    if (path_finder_can_reach_goal(Paths[i],S,G))
        {
        TruePath[i] = path_finder_path_to_goal(Paths[i],S,G) ;
        TruePathLength[i] = ds_list_size(TruePath[i]) ;
        }
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var HortPos = 1120
//Draws the Path Finder Grid
demo_path_finder_grid_draw(MyGraph,32,32,32) ;

//Controls the Paths we are showing and the type of tile we are placing
DM +=keyboard_check_pressed(ord("X"))- keyboard_check_pressed(ord("Z")) ;
CM +=keyboard_check_pressed(ord("V")) - keyboard_check_pressed(ord("C")) ;

//Constricts DM between 0 and 3
if (DM &gt; 9) { DM = 0 } ;
if (DM &lt; 0) { DM = 9 } ;

draw_set_colour(c_black) ;

//For displaying the type of algorithm we are using
var Str = ""
switch(DM)
    {
    case 0 : { Str = " Breadth First (Flood Fill) " ; } ; break ;
    case 1 : { Str = " Dijkstra Algorithm " ; } ; break ;
    case 2 : { Str = " Greedy-First Algorithm " ; } ; break ;
    case 3 : { Str = " A* (A Star) Algorithm " ; } ; break ;
    case 4 : { Str = " Breadth First (Flood Fill) (8 Directional) " } ; break ;
    case 5 : { Str = " Dijksta Algorithm (8 Directional) " } ; break ;
    case 6 : { Str = " Greedy-First Algorithm (8 Directional) " } ; break ;
    case 7 : { Str = " A* (A Star) Algorithm (8 Directional) " } ; break ;
    case 8 : { Str = " Dijkstra Algorithm (8 Directional) ( Weighted Directions ) " } ; break ;
    case 9 : { Str = " A* (A Star) Algorithm ( 8 Directional) (Weighted Directions) " } ; break ;
    }

draw_set_halign(fa_left) ;
draw_text(32,16,"Mode : " + Str) ;



//Constrict the tiles to the cases we handle
if (CM &gt; 4) { CM = 0 } ;
if (CM &lt; 0) { CM = 4 } ;

draw_set_halign(fa_left) ;
var Str = "" ;
if (CM == 0) { Str = "Start" } ;
if (CM ==1) { Str = "Goal" } ;
if (CM ==2) { Str = "Wall" } ;
if (CM ==3) { Str = "Empty" } ;
if (CM ==4) { Str = "Water" } ; 

draw_text(HortPos,160,"Tile To Place : " + Str) ;
draw_text(HortPos,200,"Use T to toggle outlines##Use R to toggle Costs") ;


if (ds_exists(TruePath[DM],ds_type_list))
    {
    draw_text(HortPos,240,"Length of Path : " + string(TruePathLength[DM])) ;
    }
else
    {
    draw_text(HortPos,240,"No Path to Goal") ;
    }

//Draws all the paths
draw_set_colour(c_red) ;
demo_path_finder_grid_draw_paths(MyGraph,Paths[DM],32,32,32) ;

//Draws the path from the start to the goal
draw_set_colour(c_blue) ;
if (path_finder_can_reach_goal(Paths[DM],S,G))
    {
    var Q = keyboard_check(ord("Q")) ;
    if (!Q)
        {
        demo_path_finder_grid_draw_true_path(MyGraph,Paths[DM],32,32,32,S,G) ;
        }
    else
        {
        draw_path(PathPath[DM],path_finder_grid_cell_get_x(MyGraph,S),path_finder_grid_cell_get_y(MyGraph,S),true) ;
        }
    }
draw_set_colour(c_white) ;

if (ShowOutlines)
    {
    demo_path_finder_grid_draw_outline(MyGraph,32,32,32) ;
    }


draw_set_colour(c_white)    ;
draw_set_halign(fa_center)  ;
draw_set_valign(fa_center)  ;

//Draws the Start and the End
draw_text((path_finder_grid_cell_get_x(MyGraph,S)+0.5)*32 + 32,(path_finder_grid_cell_get_y(MyGraph,S)+0.5)*32 + 32,"S") ;
draw_text((path_finder_grid_cell_get_x(MyGraph,G)+0.5)*32 + 32,(path_finder_grid_cell_get_y(MyGraph,G)+0.5)*32 + 32,"G") ;


//Fills the Paths Array with paths from generated from the algorithms


//Draws the Costs
if (ShowCosts)
    {
    if (DM == 1)
        {
        demo_path_finder_draw_costs(MyGraph,Costs[0],32,32,32) ;
        }
    
    if (DM == 3)
        {
        demo_path_finder_draw_costs(MyGraph,Costs[1],32,32,32) ;
        }
        
    if (DM == 5)
        {
        demo_path_finder_draw_costs(MyGraph,Costs[2],32,32,32) ;
        }
    if (DM == 7)
        {
        demo_path_finder_draw_costs(MyGraph,Costs[3],32,32,32) ;
        }
    if (DM == 8)
        {
        demo_path_finder_draw_costs(MyGraph,Costs[4],32,32,32) ;
        }
    if (DM == 9)
        {
        demo_path_finder_draw_costs(MyGraph,Costs[5],32,32,32) ;
        }
    }
    
//Draw Control Scheme
draw_set_halign(fa_left) ;
draw_set_colour(c_black);
draw_text(64,724,"Use X &amp; Z To Cycle Through The Available Paths###Use V &amp; C to Cycle Through Place-able Tiles") ;
draw_text_ext(HortPos,64,"Press Space to Generate New Grid",-1,160) ;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="84">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ShowOutlines = !ShowOutlines

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="82">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ShowCosts = !ShowCosts ;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Clear all the data structures then restart the game
var PS = array_length_1d(Paths) ;

for(var i = 0 ; i &lt; PS ; i++)
    {
    ds_map_destroy(Paths[i]) ;
    ds_list_destroy(TruePath[i]) ;
    }
    
var CS = array_length_1d(Costs)

for(var i = 0 ; i &lt; CS ; i++)
    {
    ds_map_destroy(Costs[i])
    }

ds_grid_destroy(MyGraph) ;
ds_grid_destroy(MyWeights) ;
ds_map_destroy(TerrainMap);



game_restart() ;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="16">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>screen_save("PathFinder.png") ;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
