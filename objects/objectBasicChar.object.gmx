<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_speed = 0;
XOffset = sprite_get_xoffset(sprite_index);
YOffset = sprite_get_yoffset(sprite_index);

// Basic Stats
MaxST = script_execute(scriptDiceRoll);
MaxDX = script_execute(scriptDiceRoll);
MaxIQ = script_execute(scriptDiceRoll);
MaxHT = script_execute(scriptDiceRoll);
MaxPer = script_execute(scriptDiceRoll);
MaxWill = script_execute(scriptDiceRoll);

ST = MaxST;
DX = MaxDX;
IQ = MaxIQ;
HT = MaxHT;
Per = MaxPer;
Will = MaxWill;

Lift = sqr(ST);
Encumberance = Lift * script_execute(scriptDiceRoll) / 3;

// Introduce yourself!
script_execute(scriptMessageAdd, string(object_get_name(object_index)) + " - ST: " + string(ST) + ", DX: " + string(DX) + ", IQ: " + string(IQ) + ", HT: " + string(HT) + ", Per: " + string(Per) + ", Will: " + string(Will) + " &amp; carrying " + string(Encumberance) + " lbs, which is " + string(floor(Encumberance / Lift)) + "x Lift.");

// Movement
MaxSpeed = (HT + DX) / 4;
MaxDodge = MaxSpeed + 3;
script_execute(scriptMoveDodgeCalc, id);
Initiative = 0;

// Equipment
Gun = script_execute(scriptGunLoad, irandom(ds_grid_height(global.GunList) - 1));
Armor = script_execute(scriptArmorLoad, irandom(ds_grid_height(global.ArmorList) - 1));
Gun.Ammo = Gun.GunMagSize;
SkillGuns = 13;
DoNothing = false; // took no action last turn

// Health &amp; Fatigue
MaxHP = 10;
HP = MaxHP;
MaxFP = 10;
FP = MaxFP;

// Health Info
Conscious = true;
Alive = true;
Shock = 0;
RecentlyWounded = false;
MortalWound = false;

// Dimensions
Height = 1; //sprite_get_height(sprite_index);
Size = 0;

// Movement Grid refernces
GridX = x / global.GridSize;
GridY = y / global.GridSize;
z = 1;
Height = 12; // Plates, standing
depth = -GridX - GridY - (10 * z);

// Movement Grid Variables
Path = path_add();
PathPoint = -1;
NextDirection = 0;
FacingDirection = 0;
StepTimer = room_speed / 2;
TurnTimer = room_speed / 4;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Paused to step forward, now step forward
script_execute(scriptMoveStep);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Paused to turn; now turn and pause to step forward

FacingDirection = NextDirection;
alarm[1] = StepTimer;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*if Moves &lt;= 0
{Moves = Speed;
 with (objectSpace) event_user(0);}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if global.CurrentChar == id
{event_user(2); // Movement
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// My turn!
script_execute(scriptTurnStart);

script_execute(scriptTurnEnd);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*/// NEWSHIT

var gs = global.GridSize;

// Relative target coordinates
var X = floor(mouse_x / gs) - 1;
var Y = floor(mouse_y / gs) - 1;


{//Finds that Cell ID
 var Cell = path_finder_grid_cell_get_id(global.MovementGrid, X, Y);
 G = Cell;



//If we know of a Path to the goal already, we can use it
if (path_finder_can_reach_goal(MyPaths,MyCell,TargetCell))
{
PathList = path_finder_path_to_goal(MyPaths,MyCell,TargetCell) ;
GameMakerPath = path_finder_list_to_path(MyGraph,PathList,32,32,32)
}
else //Otherwise we need to find another
{
MyPaths =
path_finder_a_star_search(MyGraph,MyWeights,MyCell,TargetCell,PF_Return_Path);
}*/
/*

//Regenerate the Weights
MyWeights = path_finder_grid_declare_weights(MyGraph, TerrainMap, 1);

//Loop through each of the Path and destroy everything to do with them
ds_map_destroy(Paths);
ds_list_destroy(TruePath); 
ds_map_destroy(Costs);

//Regenerate what we need.
Paths = path_finder_a_star_search_8d_weighted(MyGraph, MyWeights, S, G, 0, MoveWeight);

//Fills the Costs Array with costs for Dijkstra and A* Methods
Costs = path_finder_a_star_search_8d_weighted(MyGraph,MyWeights, S, G, 1, MoveWeight);

if (path_finder_can_reach_goal(Paths, S, G))
{TruePath = path_finder_path_to_goal(Paths, S, G);
 TruePathLength = ds_list_size(TruePath);}}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*/// Movement - find route, NEWSTUFF

var xx, yy, S, G;
var gs = global.GridSize;

// Destination coords
x1 = floor(x / gs) - 1 + XOffset;
y1 = floor(y / gs) - 1 + YOffset;

x2 = floor(mouse_x / gs) - 1 + XOffset;
y2 = floor(mouse_y / gs) - 1 + YOffset;

// If the cell is inside the grid
if path_finder_grid_in_bounds(global.MovementGrid, X, Y)
{// Get Cell Refernces
 S = path_finder_grid_cell_get_id(global.MovementGrid, x1, y1);
 G = path_finder_grid_cell_get_id(global.MovementGrid, x2, y2);

 // Paths generated from the algorithm
 Paths = path_finder_a_star_search_8d_weighted(global.MovementGrid, MyWeights, S, G, 0, MoveWeight);
 
 // Costs for A* Method
 Costs = path_finder_a_star_search_8d_weighted(global.MovementGrid, MyWeights, S, G, 1, MoveWeight);

 //If you can find the goal in each of the paths we'll grab the one from the start to the goal and store it in TruePath (as a ds_list) and PathPath as an actual Path
 if (path_finder_can_reach_goal(Paths, S, G))
 {TruePath = path_finder_path_to_goal(Paths, S, G);
  if (ds_exists(TruePath, ds_type_list)) {TruePathLength = ds_list_size(TruePath);}
 PathPath = path_finder_list_to_path(global.MovementGrid, TruePath, 32, 32, 32);}}

//Fetchs the Relative Coordinates for the grid
var X = floor(mouse_x / gs) - 1;
var Y = floor(mouse_y / gs) - 1;

//Finds that Cell ID
var Cell = path_finder_grid_cell_get_id(MyGraph, X, Y);
G = Cell;

/*
//If we know of a Path to the goal already, we can use it
if (path_finder_can_reach_goal(MyPaths,MyCell,TargetCell))
{
PathList = path_finder_path_to_goal(MyPaths,MyCell,TargetCell) ;
GameMakerPath = path_finder_list_to_path(MyGraph,PathList,32,32,32)
}
else //Otherwise we need to find another
{
MyPaths =
path_finder_a_star_search(MyGraph,MyWeights,MyCell,TargetCell,PF_Return_Path);
}*/

/*
//Regenerate the Weights
MyWeights = path_finder_grid_declare_weights(MyGraph, TerrainMap, 1);

//Loop through each of the Path and destroy everything to do with them
ds_map_destroy(Paths);
ds_list_destroy(TruePath); 
ds_map_destroy(Costs);

//Regenerate what we need.
Paths = path_finder_a_star_search_8d_weighted(MyGraph, MyWeights, S, G, 0, MoveWeight);

//Fills the Costs Array with costs for Dijkstra and A* Methods
Costs = path_finder_a_star_search_8d_weighted(MyGraph,MyWeights, S, G, 1, MoveWeight);

if (path_finder_can_reach_goal(Paths, S, G))
{TruePath = path_finder_path_to_goal(Paths, S, G);
 TruePathLength = ds_list_size(TruePath);}





// Old things, need updating
/*path_get_number(Path);
// Start
PathPoint = 0;
script_execute(scriptMoveTurn);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update Grid Coords
GridX = x / global.GridSize;
GridY = y / global.GridSize;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Recenter Screen on Player
view_xview[0] = x - (view_wview[0] / 2);
view_yview[0] = y - (view_hview[0] / 2);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();
draw_path(Path, 0, 0, true);
//draw_text(x, y + 32, string(path_get_number(Path)) + ", " + string(PathPoint));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
